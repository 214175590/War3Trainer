[tc]魔兽3 1.22.0.6328内存修改器 程序员手册
          [tc]天驰  2008.10.7

一、单位ESI的获得
1、内存空洞：Read / Write：003D0000
2、原来的部分：
6F353D25:
8b b4 24 ec 08 00 00	mov esi,[esp+000008ec]

6F353D25:
e9 d6 c3 07 91	jmp 003D0100
90		nop
90		nop

003D0100:
8b b4 24 ec 08 00 00	mov esi,[esp+000008ec]
89 35 00 00 3d 00	mov [003D0000], esi
e9 1a 3c f8 6e		jmp 6F353D2C

3、在6F353D25搞到的ESI，解开，
● ESI记为ThisUnit
● [ThisUnit + 1E4]记为UnitAttributes
● [ThisUnit + 1EC]记为HeroAttributes
例：[08220320 + 1E4] = 07B60424
    [08220320 + 1EC] = 05AA0094

4、重要的内存提取算法
算法0（6F03F180）：从GameMemory取得数据，需要索引号Index1和一个参考数ReferenceNumber1。注意Index1最高位不得为1，不然不是这个算法。建议判一下正负。
（1）[6FAA4178]记为ThisGame
例：[6FAA4178] = 02AE00B8
（2）[ThisGame + 0xC]计为ThisGameMemory
例：[02AE00B8 + C] = 0F060088
（3）[ThisGameMemory + Index1 * 8 + 4]计为Address1，返回之
（4）[Address1 + 0x18]应当等于ReferenceNumber1，不相等游戏会异常（访问地址0），所以做修改器不用考虑这里

算法1（6F4634E0）：也需要Index1
（1）用算法0
（2）Address1 + 0x78输出为地址

算法2（6F468A20）：也需要Index1
（1）[ThisGameMemory + Index1 * 8 + 4]，记为Address3
（2）[Address3 + 20]为零的前提下返回[Address + 54]的内容

二、单位的修改
1、HP float
[HPMax地址-C]

2、HPMax float
（1）ThisUnit + 98		// 参考sub_6F28A760
例：08220320 + 98
（2）[上面 + 8]			// 参考sub_6F467710
例：[82203C0] = 06BC
（3）用算法0解开上面
例：093E0AFC
（4）解开后内容在[上面 + 84]	// 参考6F46752F: fcompp, EDX

3、MP float
[MPMax地址-C]

4、MPMax float
（1）ThisUnit + 98		// 参考sub_6F28A760
例：08220320 + 98
（2）[上面 + 28]		// 参考sub_6F467750
例：[^+28] = 06BD
（3）用算法0解开上面
（4）解开后内容在[上面 + 84]	// 参考sub_6F467750

5、经验值：[HeroAttributes + 8C]	int
源代码：6F26DFF0
即：getHeroExp()

6、力量初值：[HeroAttributes + 94]	int
源代码：3F353D06
即：int __thiscall DrawHeroProperty(int *GameContext, int **HeroAttributes, int *AttributeBias, unsigned int *GBuffer)

7、敏捷初值：[HeroAttributes + A8]	int
源代码：同上

8、智力初值：int
源代码：6F0DA9D0
即：int __fastcall getHeroIntellect_NotSure(int pAttribute1)
[HeroAttributes + 7C + 2 * 4] 记为Index1
[HeroAttributes + 7C + 3 * 4] 记为ReferenceNumber1
用算法1得到地址

9、攻击频率：[UnitAttributes + 1B0]	float
源代码：6F0C64E0
即：int __thiscall getHeroROF_NotSure(int *this, int a2, int a3, int a4)

10-13、攻击相关：int
参考(攻击频率/UnitAttributes)	0	1B0	
攻击 - 基础			-110	 A0
攻击 - 倍乘			-11C	 94
攻击 - 骰子			-128	 88
攻击 - 种类			-BC	 F4

14、移动速度：[参数 + 70h] float 单位的移动，或者[参数 + 78h] float 当前的移动速度
源代码：6F201190
即：void __thiscall sub_6F201190(int this, int a2, int a3)

参数的获得：sub_6F077550:从6F077693开始
参考1：6f2011a1: mov eax, [ecx+70]	ecx=07c50094
< sub_6F201190(a1+0x70)
< 6F077758(arg0 = 0012F874)
参考2：断点下在6F0776F6
> [ThisUnit + 1D8]记为MoveAbilityIndex
例：06CE
算法2(^)=07e23cd4记为I
例：[I]=6F8BDBCC
（
Index依次等于：(This+1D8=)6CE       6CD       6C6、     6C5       6C4
对应算法2结果：      07E23CD4、05AA0094、05A90094、07B50424、07B50448、07C50094
Next         ：
）
while [I + 24] & [I + 28] != -1
{
	if [[I] + 2D4] == 6F201190（如果是6F052080，这个是空的）
	{
		[I + 70]为移动速度，或者用[I + 78]
		exit
	}

	I = 算法2([I + 24]) = 05AA0094、05A90094、...、07C50094
}

> 如果[+2D4] != 6F201190则
{
> [^ + 24]作为Index
06CD
> 解index
[ED236F4]=084BEEC4
[^+54]= 05aa0094
}

15、防御：[ThisUnit + E0]	float
源代码：6F353250
6F3532A2: mov eax, dword ptr [ebx+e0]
即：void __thiscall sub_6F353250(int this, int a2, int a3, int a4)

16、防御类型：[ThisUnit + E4]	int

三、金钱的修改
参考：6F407220，看最后一段
即：signed int __thiscall sub_6F407220(int this, signed int a2, unsigned int a3, int a4, int a5, int a6)

1、上16位
（1）[ThisGameMemory + 1 * 8 + 4]计为Address2
（2）Address2上16位，下16位见下一款

2、下16位
1P	0190
2P	1410
3P	26a0
4P	3920
5P	4bb0
6P	5e30
7P	70c0
8P	8350
9P	95d0
10P	a860

3、对每个玩家
金钱	    0	int x10
木头	 + 80	int x10
最大人口 +180	int
当前人口 +200	int


